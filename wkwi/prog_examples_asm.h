// -----------------------------------------------------------------------------
// Altair 8800 Simulator
//
// This file contains copies of a the following assembler programs:
// - DUMP program from MITS Programming System II manual (C) MITS 1976
// - Pong on Altair via terminal (C) David Hansel 2017
//
// While the Altair 8800 simulator code itself is released under GPLv3, 
// the contents of this file are excluded from that license for obvious reasons.
// -----------------------------------------------------------------------------

// [this gets included from prog_examples.cpp]

#include "config.h"

#if USE_Z80==0

const char asm_dump[] =
  "\tORG\t20000Q\t;SET LOCATION COUNTER\r"
  "DUMP:\tLHLD\tFIRST\t;GET ADDRESS OF FIRST BYTE TO BE DUMPED\r"
  "\tXCHG\t\t;PUT ADDRESS IN D&E\r"
  "NEWLN:\tLXI\tH,BUF\t;GET ADDDRESS OF OUTPUT BUFFER\r"
  "\tPUSH\tH\t;SAVE ADDRESS\r"
  "\tLHLD\tLAST\t;LOAD ADDRESS OF LAST BYTE TO BE DUMPED\r"
  "\tMOV\tA,L\t;SUBTRACT LOW ORDER BYTES\r"
  "\tSUB\tE\r"
  "\tMOV\tA,H\t;SUBTRACT HIGH ORDER BYTE\r"
  "\tSBB\tD\r"
  "\tPOP\tH\t;RESTORE H&L\r"
  "\tJC\tMON\t;JUMPS OUT IF NO MORE BYTES TO BE DUMPED\r"
  "\tMOV\tA,D\t;START CONVERSION OF ADDRESS TO ASCII\r"
  "\tRAL\t\t;ROTATE HIGH BIT INTO C\r"
  "\tMVI\tA,0\t;ZERO OUT REST OF A BUT DONT CHANGE FLAGS\r"
  "\tRAL\t\t;ROTATE HIGH BIT INTO LOW ORDER POSITION\r"
  "\tORI\t60Q\t;OR IN ASCII 0\r"
  "\tMOV\tM,A\t;STORE IN OUTPUT BUFFER\r"
  "\tINX\tH\t;INCREMENT BUFFER POINTER\r"
  "\tMOV\tA,D\t;PICK UP HIGH ORDER BITE AGAIN\r"
  "\tRAR\t;ROTATE BITS 4,5,6 INTO LOW ORDER POSITIONS\r"
  "\tRAR\r"
  "\tRAR\r"
  "\tRAR\r"
  "\tANI\t7\t;MASK OFF ALL BITS EXCEPT LOW THREE\r"
  "\tORI\t60Q\t;OR IN ASCII 0\r"
  "\tMOV\tM,A\t;STORE IN OUTPUT BUFFER\r"
  "\tINX\tH\t;INCREMENT POINTER INTO OUTPUT BUFFER\r"
  "\tMOV\tA,D\t;PICK UP HIGH BYTE OF ADDRESS\r"
  "\tRAR\t\t;ROTATE BITS 1,2,3 INTO LOW ORDER POSITION\r"
  "\tANI\t7\t;MASK OFF ALL BITS EXCEPT LOW THREE\r"
  "\tORI\t60Q\t;OR IN ASCII 0\r"
  "\tMOV\tM,A\t;STORE IN OUTPUT BUFFER\r"
  "\tINX\tH\t;INCREMENT POINTER INTO OUTPUT BUFFER\r"
  "\tMOV\tA,D\t;PICK UP HIGH BYTE OF ADDRESS\r"
  "\tRAR\t\t;SAVE LOW BIT IN THE CARRY FLAG\r"
  "\tMOV\tA,E\t;PICK UP LOW BYTE OF ADDRESS\r"
  "\tCALL\tLAST3\t;CALL SUBROUTINE THAT CONVERTS 3 DIGITS\r"
  "\tMVI\tB,8\t;LOAD B WITH NO OF BYTES TO DUMP PER LINE\r"
  "NXTNUM:\tPUSH\tH\t;SAVE H&L\r"
  "\tLHLD\tLAST    ;LOAD ADDRESS OF LAST BYTE TO DUMP\r"
  "\tMOV\tA,L\t;DO THE DOUBLE WORD COMPARE AGAIN\r"
  "\tSUB\tE\r"
  "\tMOV\tA,H\r"
  "\tSBB\tD\r"
  "\tPOP\tH\t;RESTORE THE H&L REGISTERS\r"
  "\tJC\tLNDN\t;JUMP TO ROUTINE TO FINISH UP IF DONE\r"
  "\tMVI\tC,5\t;IF ANOTHER TO COME SEPERATE THEM BY 5 BLANKS\r"
  "\tCALL\tBLANK\r"
  "\tXRA\tA\t;SET THE CARRY FLAG TO 0\r"
  "\tLDAX\tD\t;GET BYTE TO DUMP\r"
  "\tCALL\tLAST3\t;CALL ROUTINE TO CONVERT 3 DIGITS\r"
  "\tINX\tD\t;INCREMENT POINTER TO DUMP NEXT BYTE\r"
  "CHKLN:\tDCR\tB\t;DECREMENT LINE BYTE COUNTER\r"
  "\tJNZ\tNXTNUM\t;CONVERT NEXT NUMBER IF IT WILL FIT ON LINE\r"
  "\tLXI\tB,OUT\t;GET ADDRESS OF MONITOR CONTROL BLOCK\r"
  "\tCALL\tIO\t;WRITE OUT LINE\r"
  "\tJMP\tNEWLN\t;JUMP TO WRITE OUT NEXT LINE\r"
  "LNDN:\tMVI\tC,8\t;PAD LINE WITH 8 BLANKS FOR EACH NUMBER THAT\r"
  "\tCALL\tBLANK\t;WOULD FIT\r"
  "\tDCR\tB\t;DECREMENT NUMBERS THAT COULD FIT IN LINE\r"
  "\tJNZ\tLNDN\t;LOOP UNTIL LINE FILLED WITH BLANKS\r"
  "\tLXI\tB,OUT\t;GET ADDRESS OF MONITOR CONTROL BLOCK\r"
  "\tCALL\tIO\t;WRITE OUT LINE\r"
  "\tJMP\tMON\t;BACK TO MONITOR\r"
  "BLANK:\tMVI\tA,40Q\t;PUT A ASCII BLANK IN A\r"
  "BL:\tMOV\tM,A\t;STORE IT IN THE OUTPUT BUFFER\r"
  "\tINX\tH\t;INCREMENT THE OUTPUT BUFFER POINTER\r"
  "\tDCR\tC\t;DECREMENT THE NUMBER OF BLANKS TO STORE\r"
  "\tJNZ\tBL\t;LOOP UNTIL ALL STORED\r"
  "\tRET\t\t;RETURN TO CALLER\r"
  "LAST3:\tPUSH\tPSW\t;SAVE BYTE TO CONVERT\r"
  "\tRAL\t\t;ROTATE CARRY AND HIGH 2 BITS TO LOW ORDER\r"
  "\tRAL\t\t;POSITION\r"
  "\tRAL\r"
  "\tANI\t7\t;MASK OFF ALL BUT LOW ORDER THREE BITS\r"
  "\tORI\t60Q\t;OR IN A ASCII 0\r"
  "\tMOV\tM,A\t;STORE DIGIT IN OUTPUT BUFFER\r"
  "\tINX\tH\t;INCREMENT THE OUTPUT BUFFER POINTER\r"
  "\tPOP\tPSW\t;POP BYTE TO CONVERT\r"
  "\tPUSH\tPSW\t;SAVE FOR LATER ALSO\r"
  "\tRAR\t\t;ROTATE BITS 3,4,5 INTO LOW ORDER POSITION\r"
  "\tRAR\r"
  "\tRAR\r"
  "\tANI\t7\t;MASK OFF ALL BUT LOW THREE BITS\r"
  "\tORI\t60Q\t;OR IN AN ASCII 0\r"
  "\tMOV\tM,A\t;STORE DIGIT IN OUTPUT BUFFER\r"
  "\tINX\tH\t;INCREMENT OUTPUT BUFFER POINTER\r"
  "\tPOP\tPSW\t;POP BYTE TO CONVERT\r"
  "\tANI\t7\t;MASK OFF ALL BUT LOW THREE BYTES\r"
  "\tORI\t60Q\t;OR IN ASCII 0\r"
  "\tMOV\tM,A\t;STORE DIGIT IN OUTPUT BUFFER\r"
  "\tINX\tH\t;INCREMENT OUTPUT BUFFER POINTER\r"
  "\tRET\t\t;RETURN TO CALLER\r"
  "OUT:\tDB\t22Q\t;MONITOR WRITE OPERATION CODE\r"
  "\tDB\t\"LST\"\t;SYMBOLIC DEVICE TO WRITE ON\r"
  "\tDW\tBUF\t;ADDRESS OF OUTPUT BUFFER\r"
  "\tDW\t72\t;WRITE OUT 72 CHARATERS\r"
  "\tDW\tSTAT\t;ADDRESS OF STATUS WORD\r"
  "STAT:\tDW\t0\r"
  "FIRST:\tDW\t15100Q\r"
  "LAST:\tDW\t15272Q\r"
  "BUF:\tDS\t70\t;RESERVE 70 MEMORY LOCATIONS\r"
  "\tDB\t15Q\t;ASCII CARRIAGE RETURN\r"
  "\tDB\t12Q\t;ASCII LINE FEED\r"
  "\tBEG\tDUMP\t;SETS ADDRESS OF PLACE TO START PROGRAM\r"
  "\tEND\tDMP\r";


const char asm_pong[] =
  "\tORG\t2000H\r"
  "\t;INITIALIZE SCREEN\r"
  "START:\tLXI\tSP,STCK\t;SET STACK POINTER\r"
  "\tLXI\tH,INITS\t;CLEAR SCREEN AND HIDE CURSOR\r"
  "\tCALL\tSTROUT\r"
  "\t;INITIALIZE SCORE\r"
  "\tMVI\tA,0\t;SET INITIAL SCORES TO 0\r"
  "\tSTA\tSCR1\r"
  "\tSTA\tSCR2\r"
  "\tCALL\tPSCR\t;PRINT INITIAL SCORES\r"
  "\t;INITIALIZE PLAYERS\r"
  "\tMVI\tA,9\t;PLAYER 1 STARTS AT ROW 9\r"
  "\tSTA\tP1R\r"
  "\tMOV\tD,A\r"
  "\tMVI\tA,9\t;PLAYER 2 STARTS AT ROW 9\r"
  "\tSTA\tP2R\r"
  "\tMOV\tE,A\r"
  "\tMOV\tB,D\t;MOVE CURSOR TO ROW/COL OF PLAYER 1\r"
  "\tMVI\tC,1\r"
  "\tCALL\tMOVC\r"
  "\tLXI\tH,PLYRS\t;DISPLAY PLAYER\r"
  "\tCALL\tSTROUT\r"
  "\tMOV\tB,E\t;MOVE CURSOR TO ROW/COL OF PLAYER 2\r"
  "\tMVI\tC,70\r"
  "\tCALL\tMOVC\r"
  "\tLXI\tH,PLYRS\t;DISPLAY PLAYER\r"
  "\tCALL\tSTROUT\r"
  "\t;INITIALIZE BALL\r"
  "\tMVI\tB,089H\t;START AT ROW 9,GOING DOWN\r"
  "\tMVI\tC,0A3H\t;START AT COLUMN 35,GOING RIGHT\r"
  "\t;MANAGE VERTICAL BALL DIRECTION\r"
  "LOOP:\tMOV\tA,B\t;CHECK ROW\r"
  "\tANI\t7FH\t;MASK OUT BIT 7\r"
  "\tCPI\t20\t;AT ROW 20?\r"
  "\tJNZ\tL1\r"
  "\tMOV\tB,A\t;YES => CLEAR BIT 7 (REVERSE DIRECTION)\r"
  "L1:\tCPI\t2\t;AT ROW 2?\r"
  "\tJNZ\tL2\r"
  "\tORI\t80H\t;YES => SET BIT 7 (REVERSE DIRECTION)\r"
  "\tMOV\tB,A\r"
  "\t;MANAGE HORIZONTAL BALL DIRECTION\r"
  "L2:\tMOV\tA,B\t;BALL ROW TO H\r"
  "\tANI\t7FH\r"
  "\tMOV\tH,A\r"
  "\tMOV\tA,C\t;BALL COLUMN TO L\r"
  "\tANI\t7FH\r"
  "\tMOV\tL,A\r"
  "\tCPI\t69\t;CHECK IF COLUMN = 69\r"
  "\tJNZ\tL41\r"
  "\tMOV\tA,H\r"
  "\tCMP\tE\r"
  "\tJM\tSCP1\t;BALL ROW < PLAYER 2 => PLAYER 1 SCORES\r"
  "\tSUI\t3\r"
  "\tCMP\tE\r"
  "\tJP\tSCP1\t;BALL ROW - 3 >= PLAYER 2 => PLAYER 1 SCORES\r"
  "\tMOV\tC,L\t;MAKE BALL MOVE LEFT\r"
  "\tJMP\tL42\r"
  "L41:\tMOV\tA,L\r"
  "\tCPI\t2\t;CHECK IF COLUMN = 2\r"
  "\tJNZ\tL42\r"
  "\tMOV\tA,H\r"
  "\tCMP\tD\r"
  "\tJM\tSCP2\t;BALL ROW < PLAYER 1 => PLAYER 2 SCORES\r"
  "\tSUI\t3\r"
  "\tCMP\tD\r"
  "\tJP\tSCP2\t;BALL ROW - 3 >= PLAYER 1 => PLAYER 2 SCORES\r"
  "\tMOV\tA,L\t;MAKE BALL MOVE RIGHT\r"
  "\tORI\t80H\r"
  "\tMOV\tC,A\r"
  "L42:\tPUSH\tB\t;SAVE BALL POSITION\r"
  "\t; CHECK INPUTS\r"
  "CHKIN:\tIN\t10H\r"
  "\tRRC\r"
  "\tJNC\tMPLYR\r"
  "\tIN\t11H\r"
  "\tANI\t0DFH\t;ACCEPT LOWERCASE\r"
  "\tLXI\tH,P1R\r"
  "\tCPI\t65\t; \"A\" => PLAYER 1 UP\r"
  "\tJNZ\tL3A\r"
  "\tLDA\tP1R\r"
  "\tCPI\t2\r"
  "\tJM\tCHKIN\r"
  "\tDCR\tM\r"
  "\tJMP\tCHKIN\r"
  "L3A:\tCPI\t90\t; \"Z\" => PLAYER 1 DOWN\r"
  "\tJNZ\tL3B\r"
  "\tLDA\tP1R\r"
  "\tCPI\t18\r"
  "\tJP\tCHKIN\r"
  "\tINR\tM\r"
  "\tJMP\tCHKIN\r"
  "L3B:\tLXI\tH,P2R\r"
  "\tCPI\t75\t; \"K\" => PLAYER 2 UP\r"
  "\tJNZ\tL3C\r"
  "\tLDA\tP2R\r"
  "\tCPI\t2\r"
  "\tJM\tCHKIN\r"
  "\tDCR\tM\r"
  "\tJMP\tCHKIN\r"
  "L3C:\tCPI\t77\t; \"M\" => PLAYER 2 DOWN\r"
  "\tJNZ\tCHKIN\r"
  "\tLDA\tP2R\r"
  "\tCPI\t18\r"
  "\tJP\tCHKIN\r"
  "\tINR\tM\r"
  "\tJMP\tCHKIN\r"
  "\t;MANAGE PLAYER 1\r"
  "MPLYR:\tLDA\tP1R\r"
  "\tMOV\tB,D\r"
  "\tMVI\tC,1\r"
  "\tCALL\tPLYR\r"
  "\tMOV\tD,B\r"
  "\t;MANAGE PLAYER 2\r"
  "\tLDA\tP2R\r"
  "\tMOV\tB,E\r"
  "\tMVI\tC,70\r"
  "\tCALL\tPLYR\r"
  "\tMOV\tE,B\r"
  "\t;MOVE BALL\r"
  "BALL:\tPOP\tB\t;RESTORE BALL POSIION\r"
  "\tCALL \tMOVC\t;MOVE CURSOR TO CURRENT BALL POSITION\r"
  "\tMVI\tA,\" \"\t;ERASE BALL AT CURRENT POSITION\r"
  "\tCALL\tCHROUT\r"
  "\tMOV\tA,C\t;ONLY MOVE VECRTIAL AT EVERY OTHER\r"
  "\tANI\t1\t;HORIZONTAL STEP\r"
  "\tJZ\tL11\r"
  "\tMOV\tA,B\t;CHECK VERTICAL BALL DIRECTION\r"
  "\tORA\tA\r"
  "\tJP\tL10\t;JUMP IF BIT 7 IS 0 (MOVING DOWN)\r"
  "\tINR\tB\t;BIT 7 IS 1 (MOVING UP)\r"
  "\tJMP\tL11                 \r"
  "L10:\tDCR\tB\t;BIT 7 IS 0 (MOVING DOWN)\r"
  "L11:\tMOV\tA,C\t;CHECK HORIZONTAL BALL DIRECTION\r"
  "\tORA\tA                   \r"
  "\tJP\tL20\t;JUMP IF BIT 7 IS 0 (MOVING LEFT)\r"
  "\tINR\tC\t;BIT 7 IS 1 (MOVING RIGHT)\r"
  "\tJMP\tL21\r"
  "L20:\tDCR\tC\t;BIT 7 IS 0 (MOVING LEFT)\r"
  "L21:\tCALL\tMOVC\t;MOVE CURSOR TO NEW BALL POSITION\r"
  "\tMVI\tA,\"*\"\t;DRAW BALL AT NEW POSITION\r"
  "\tCALL\tCHROUT\r"
  "\t;START NEXT CYCLE\r"
  "\tJMP\tLOOP\r"
  "PLYR:\tCMP\tB\r"
  "\tJZ\tPNOP\r"
  "\tJM\tPUP\r"
  "PDN:\tCALL\tMOVC\t;MOVING DOWN\r"
  "\tMVI\tA,\" \"\r"
  "\tCALL\tCHROUT\r"
  "\tINR\tB\r"
  "\tINR\tB\r"
  "\tINR\tB\r"
  "\tCALL\tMOVC\r"
  "\tMVI\tA,\"I\"\r"
  "\tCALL\tCHROUT\r"
  "\tDCR\tB\r"
  "\tDCR\tB\r"
  "\tRET\r"
  "PUP:\tDCR\tB\t;MOVING UP\r"
  "\tCALL\tMOVC\r"
  "\tMVI\tA,\"I\"\r"
  "\tCALL\tCHROUT\r"
  "\tINR\tB\r"
  "\tINR\tB\r"
  "\tINR\tB\r"
  "\tCALL\tMOVC\r"
  "\tMVI\tA,\" \"\r"
  "\tCALL\tCHROUT\r"
  "\tDCR\tB\r"
  "\tDCR\tB\r"
  "\tDCR\tB\r"
  "\tRET\r"
  "PNOP:\tCALL\tMOVC\t;NOT MOVING\r"
  "\tMVI\tA,\"I\"\r"
  "\tCALL\tCHROUT\r"
  "\tCALL\tMOVC\r"
  "\tMVI\tA,\"I\"\r"
  "\tJMP\tCHROUT\r"
  "\t;PLAYER 1 SCORES\r"
  "SCP1:\tLDA\tSCR1\t;INCREASE SCORE OF PLAYER 1\r"
  "\tINR\tA\r"
  "\tSTA\tSCR1\r"
  "\tCPI\t10\r"
  "\tJZ\tEND\t;IF SCORE=10 then end game\r"
  "\tCALL\tPSCR\t;PRINT SCORES\r"
  "\tCALL\tMOVC\t;MOVE TO CURRENT POSITION OF BALL\r"
  "\tMVI\tA,\" \"\t;ERASE BALL\r"
  "\tCALL\tCHROUT\r"
  "\tMVI\tB,89H\t;START IN ROW 9,MOVING DOWN\r"
  "\tMVI\tC,23H\t;START IN COLUMN 35,MOVING LEFT\r"
  "\tJMP\tLOOP\t;START NEXT CYCLE\r"
  "\t;PLAYER 2 SCORES\r"
  "SCP2:\tLDA  SCR2\t;INCREASE SCORE OF PLAYER 2\r"
  "\tINR\tA\r"
  "\tSTA\tSCR2\r"
  "\tCPI\t10\r"
  "\tJZ\tEND\t;IF SCORE=10 then end game\r"
  "\tCALL\tPSCR\t;PRINT SCORES\r"
  "\tCALL\tMOVC\t;MOVE TO CURRENT POSITION OF BALL\r"
  "\tMVI\tA,\" \"\t;ERASE BALL\r"
  "\tCALL\tCHROUT\r"
  "\tMVI\tB,089H\t;START IN ROW 9,MOVING DOWN\r"
  "\tMVI\tC,0A3H\t;START IN COLUMN 35,MOVING RIGHT\r"
  "\tJMP\tLOOP\t;START NEXT CYCLE\r"
  "\t;PRINT BOTH PLAYER'S SCORES\r"
  "END:\tLXI\tH,ENDS\t;CLEAR SCREEN AND SHOW CURSOR\r"
  "\tCALL\tSTROUT\r"
  "EMPTY:\tIN\t10H\t;EMPTY INPUT BUFFER\r"
  "\tRRC\r"
  "\tJNC\tMON\t;BACK TO MONITOR\r"
  "\tIN\t11H\r"
  "\tJMP\tEMPTY\r"
  "PSCR:\tPUSH\tB\t;SAVE BALL POSITION\r"
  "\tMVI\tB,1\t;MOVE CURSOR TO ROW 1,COLUMN 10\r"
  "\tMVI\tC,10               \r"
  "\tCALL\tMOVC\r"
  "\tLDA\tSCR1\t;LOAD PLAYER 1 SCORE\r"
  "\tCALL\tDSPN\t;PRINT NUMBER IN A\r"
  "\tMVI\tB,1\t;MOVE CURSOR TO ROW 1,COLUMN 60\r"
  "\tMVI\tC,60\r"
  "\tCALL\tMOVC\r"
  "\tLDA\tSCR2\t;LOAD PLAYER 2 SCORE\r"
  "\tCALL\tDSPN\t;PRINT NUMBER IN A\r"
  "\tPOP\tB\t;RESTORE BALL POSITION\r"
  "\tRET\r"
  "\t;MOVE CURSOR TO POSITION IN B (ROW) AND C (COLUMN)\r"
  "MOVC:\tMVI\tA,1BH\t;PRINT ESC\r"
  "\tCALL\tCHROUT\r"
  "\tMVI\tA,\"[\"\t;PRINT '['\r"
  "\tCALL\tCHROUT\r"
  "\tMOV\tA,B\t;ROW TO A\r"
  "\tANI\t7FH\t;CLEAR BIT 7\r"
  "\tCALL\tDSPN\t;PRINT NUMBER IN A\r"
  "\tMVI\tA,\";\"\t;PRINT ';'\r"
  "\tCALL\tCHROUT\r"
  "\tMOV\tA,C\t;COLUMN TO A\r"
  "\tANI\t7FH\t;CLEAR BIT 7\r"
  "\tCALL\tDSPN\t;PRINT NUMBER IN A\r"
  "\tMVI\tA,\"H\"\t;PRINT 'H;\r"
  "\tCALL\tCHROUT\r"
  "\tRET\r"
  "\t;PRINT 2-DIGIT DECIMAL NUMBER IN A\r"
  "DSPN:\tMVI H,0\t;10S DIGIT IS 0\r"
  "DSPL1:\tINR H\t;INCREASE 10S DIGIT\r"
  "\tSBI\t10\t;SUBTRACT 10 FROM SCORE\r"
  "\tJNC\tDSPL1\t;REPEAT UNTIL OVERFLOW\r"
  "\tDCR\tH\t;OVERSHOT BY ONE\r"
  "\tADI\t10\t;INCREASE BY 10 AGAIN TO GET 1S DIGIT\r"
  "\tMOV\tL,A\t;SAVE 1S DIGIT\r"
  "\tMOV\tA,H\t;GET 10S DIGIT\r"
  "\tADI\t30H\t;ADD 48 TO GET ASCII VALUE\r"
  "\tCALL\tCHROUT\t;PRINT DIGIT\r"
  "\tMOV\tA,L\t;GET 1S DIGIT\r"
  "\tADI\t30H\t;ADD 48 TO GET ASCII VALUE\r"
  "\tCALL\tCHROUT\t;PRINT DIGIT\r"
  "\tRET\r"
  "\t;PRINT STRING POINTED TO BY H/L\r"
  "STROUT:\tMOV\tA,M\t;LOAD NEXT CHARACTER\r"
  "\tORA\tA\t;UPDATE Z FLAG\r"
  "\tRZ\t\t;RETURN IF 0\r"
  "\tCALL\tCHROUT\t;OUTPUT CHARACTER\r"
  "\tINX\tH\t;INCREASE POINTER\r"
  "\tJMP\tSTROUT\t;START OVER\r"
  "CHROUT:\tPUSH\tA\r"
  "WAIT:\tIN\t10H\r"
  "\tRRC\r"
  "\tRRC\r"
  "\tJNC\tWAIT\r"
  "\tPOP\tA\r"
  "\tOUT\t11H\r"
  "\tRET\r"
  "SCR1:\tDB\t0\t\t;PLAYER 1 SCORE\r"
  "SCR2:\tDB\t0\t\t;PLAYER 2 SCORE\r"
  "INITS:\tDB\t27,\"[2J\"\t;CLEAR SCREEN\r"
  "\tDB\t27,\"[?25\",108\t;HIDE CURSOR\r"
  "\tDB\t0\r"
  "ENDS:\tDB\t27,\"[2J\"\t;CLEAR SCREEN\r"
  "\tDB\t27,\"[H\"\t\t;CURSOR HOME\r"
  "\tDB\t27,\"[?25\",104\t;SHOW CURSOR\r"
  "\tDB\t0\r"
  "\t;PLAYER ICON\r"
  "PLYRS:\tDB\t\"I\"\t\t;'I'\r"
  "\tDB\t27,\"[1D\"\t;CURSOR LEFT\r"
  "\tDB\t27,\"[1B\"\t;CURSOR DOWN\r"
  "\tDB\t\"I\"\t\t;'I'\r"
  "\tDB\t27,\"[1D\"\t;CURSOR LEFT\r"
  "\tDB\t27,\"[1B\"\t;CURSOR DOWN\r"
  "\tDB\t\"I\"\t\t;'I'\r"
  "\tDB\t0\r"
  "P1R:\tDB\t0\t;PLAYER1 REQUESTED POS\r"
  "P2R:\tDB\t0\t;PLAYER2 REQUESTED POS\r"
  "STCKB:\tDS\t16\t;RESERVE 16 BYTES FOR STACK\r"
  "STCK:\tBEG\tSTART\r"
  "\tEND\tPONG\r";


const char asm_dir[] =
  "10000000) [this directory]\r"
  "10000001) pong\r"
  "10000010) memory dump\r";


const char * const asm_programs[]  = {
  asm_dir,
  asm_pong,
  asm_dump};

#else

const char asm_dir[] =
  "10000000) [this directory]\r";

const char * const asm_programs[]  = {asm_dir};

#endif

byte read_asm_example(int n, int i) { return ((byte) asm_programs[n][i]); }
#define NUM_ASM_PROGRAMS (sizeof(asm_programs)/sizeof(char *))
